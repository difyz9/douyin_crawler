#!/usr/bin/env python3
"""
æŠ–éŸ³ç›´æ’­é—´æ•°æ®çˆ¬è™« CLI ç‰ˆæœ¬
ä¸“é—¨ç”¨äºé‡‡é›†ç›´æ’­é—´å¼¹å¹•ã€ç¤¼ç‰©ã€è§‚ä¼—ç­‰æ•°æ®
"""

import codecs
import gzip
import hashlib
import json
import os
import random
import re
import string
import subprocess
import threading
import time
import urllib.parse
from contextlib import contextmanager
from datetime import datetime
from unittest.mock import patch
import sys
import argparse
import logging

import requests
import websocket
from protobuf.douyin import *

# JavaScriptè¿è¡Œæ—¶
_js_runtime = None

def get_js_runtime():
    """è·å–JavaScriptè¿è¡Œæ—¶ç¯å¢ƒ"""
    global _js_runtime
    
    if _js_runtime is not None:
        return _js_runtime
        
    try:
        # ä¼˜å…ˆå°è¯•ä½¿ç”¨ py_mini_racer
        from py_mini_racer import MiniRacer
        _js_runtime = MiniRacer()
        logger.info("ä½¿ç”¨ py_mini_racer ä½œä¸ºJavaScriptè¿è¡Œæ—¶")
        return _js_runtime
    except ImportError:
        try:
            # å¤‡é€‰ä½¿ç”¨ PyExecJS
            import execjs
            _js_runtime = execjs
            logger.info("ä½¿ç”¨ PyExecJS ä½œä¸ºJavaScriptè¿è¡Œæ—¶")
            return _js_runtime
        except ImportError:
            logger.error("æœªå®‰è£…JavaScriptè¿è¡Œæ—¶ç¯å¢ƒï¼Œè¯·å®‰è£…: pip install mini-racer æˆ– pip install PyExecJS")
            return None

def clear_js_runtime_cache():
    """æ¸…ç†JavaScriptè¿è¡Œæ—¶ç¼“å­˜"""
    global _js_runtime
    _js_runtime = None

def generateMsToken(length=107):
    """
    äº§ç”Ÿè¯·æ±‚å¤´éƒ¨cookieä¸­çš„msTokenå­—æ®µï¼Œå…¶å®ä¸ºéšæœºçš„107ä½å­—ç¬¦
    :param length:å­—ç¬¦ä½æ•°
    :return:msToken
    """
    random_str = ""
    base_str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789="
    for _ in range(length):
        random_str += base_str[random.randint(0, len(base_str) - 1)]
    return random_str

# è®¾ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('data/logs/crawler.log', encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)

def get_resource_path(relative_path):
    """è·å–èµ„æºæ–‡ä»¶çš„ç»å¯¹è·¯å¾„"""
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")
    
    possible_paths = [
        os.path.join(base_path, relative_path),
        os.path.join(os.path.dirname(os.path.abspath(__file__)), relative_path),
        os.path.join(os.getcwd(), relative_path),
        os.path.abspath(relative_path),
    ]
    
    for path in possible_paths:
        if os.path.exists(path):
            return path
            
    return os.path.join(base_path, relative_path)

@contextmanager
def patched_popen_encoding(encoding='utf-8'):
    original_popen_init = subprocess.Popen.__init__
    
    def new_popen_init(self, *args, **kwargs):
        kwargs['encoding'] = encoding
        original_popen_init(self, *args, **kwargs)
    
    with patch.object(subprocess.Popen, '__init__', new_popen_init):
        yield

def generateSignature(wss, script_file='sign.js'):
    """ç”Ÿæˆç­¾å"""
    params = ("live_id,aid,version_code,webcast_sdk_version,"
             "room_id,sub_room_id,sub_channel_id,did_rule,"
             "user_unique_id,device_platform,device_type,ac,"
             "identity").split(',')
    
    try:
        wss_params = urllib.parse.urlparse(wss).query.split('&')
        wss_maps = {i.split('=')[0]: i.split("=")[-1] for i in wss_params if '=' in i}
        tpl_params = [f"{i}={wss_maps.get(i, '')}" for i in params]
        param = ','.join(tpl_params)
        
        md5 = hashlib.md5()
        md5.update(param.encode())
        md5_param = md5.hexdigest()
        
        js_runtime = get_js_runtime()
        if not js_runtime:
            logger.error("æ— æ³•è·å–JavaScriptè¿è¡Œæ—¶")
            return None
            
        # è¯»å–JavaScriptæ–‡ä»¶
        script_path = get_resource_path(script_file)
        if not os.path.exists(script_path):
            logger.error(f"ç­¾åè„šæœ¬æ–‡ä»¶ä¸å­˜åœ¨: {script_path}")
            return None
            
        with open(script_path, 'r', encoding='utf-8') as f:
            js_code = f.read()
        
        # æ ¹æ®ä¸åŒçš„è¿è¡Œæ—¶æ‰§è¡ŒJavaScript
        if hasattr(js_runtime, 'eval'):  # py_mini_racer
            js_runtime.eval(js_code)
            signature = js_runtime.call("get_sign", md5_param)
        else:  # PyExecJS
            ctx = js_runtime.compile(js_code)
            signature = ctx.call("get_sign", md5_param)
            
        return signature
            
    except Exception as e:
        logger.error(f"ç”Ÿæˆç­¾åæ—¶å‡ºé”™: {str(e)}")
        return None

class DouyinLiveCrawler:
    def __init__(self, live_id, auto_save_interval=300):
        """åˆå§‹åŒ–ç›´æ’­çˆ¬è™«"""
        self.__ttwid = None
        self.__room_id = None
        self.live_id = live_id
        self.live_url = "https://live.douyin.com/"
        self.user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        
        # WebSocketç›¸å…³
        self.ws = None
        self.ws_thread = None
        self.heartbeat_thread = None
        self.is_running = True
        
        # æ•°æ®ç»Ÿè®¡
        self.data_dir = os.path.join("data", "live_data")
        self.today = datetime.now().strftime("%Y-%m-%d")
        self.session_count = self._get_next_session_count()
        
        # æ•°æ®å­˜å‚¨
        self.data = {
            "live_id": live_id,
            "date": self.today,
            "session": self.session_count,
            "user_id": "",
            "nickname": "",
            "total_viewers": 0,
            "total_likes": 0,
            "chat_messages": [],
            "gifts": {},
            "members": set(),
            "follows": []
        }
        
        # å»é‡é›†åˆ
        self.message_cache = {
            "members": set(),
            "gifts": set()
        }
        self.cache_expire_time = 10
        self.last_cache_clean = time.time()
        
        # è‡ªåŠ¨ä¿å­˜è®¾ç½®
        self.auto_save_interval = auto_save_interval
        self.auto_save_thread = None
        self.auto_save_running = False
        
        # çŠ¶æ€å›è°ƒ
        self.status_callback = None
        self.is_live = True
        
        # ç¡®ä¿æ•°æ®ç›®å½•å­˜åœ¨
        os.makedirs(self.data_dir, exist_ok=True)
        os.makedirs("data/logs", exist_ok=True)

    def _get_next_session_count(self):
        """è·å–ä¸‹ä¸€ä¸ªåœºæ¬¡ç¼–å·"""
        import glob
        pattern = os.path.join(self.data_dir, f"{self.live_id}_*_*.json")
        files = glob.glob(pattern)
        max_count = 0
        
        for file in files:
            try:
                count = int(os.path.basename(file).split("_")[1])
                max_count = max(max_count, count)
            except (ValueError, IndexError):
                continue
                
        return max_count + 1

    @property
    def ttwid(self):
        """
        äº§ç”Ÿè¯·æ±‚å¤´éƒ¨cookieä¸­çš„ttwidå­—æ®µï¼Œè®¿é—®æŠ–éŸ³ç½‘é¡µç‰ˆç›´æ’­é—´é¦–é¡µå¯ä»¥è·å–åˆ°å“åº”cookieä¸­çš„ttwid
        :return: ttwid
        """
        if self.__ttwid:
            return self.__ttwid
        headers = {
            "User-Agent": self.user_agent,
        }
        try:
            response = requests.get(self.live_url, headers=headers)
            response.raise_for_status()
        except Exception as err:
            logger.error(f"è¯·æ±‚ç›´æ’­é¦–é¡µå¤±è´¥: {err}")
        else:
            self.__ttwid = response.cookies.get('ttwid')
            return self.__ttwid
    
    @property
    def room_id(self):
        """
        æ ¹æ®ç›´æ’­é—´çš„åœ°å€è·å–åˆ°çœŸæ­£çš„ç›´æ’­é—´roomId
        :return:room_id
        """
        if self.__room_id:
            return self.__room_id
        url = self.live_url + self.live_id
        headers = {
            "User-Agent": self.user_agent,
            "cookie": f"ttwid={self.ttwid}&msToken={generateMsToken()}; __ac_nonce=0123407cc00a9e438deb4",
        }
        try:
            response = requests.get(url, headers=headers)
            response.raise_for_status()
        except Exception as err:
            logger.error(f"è¯·æ±‚ç›´æ’­é—´é¡µé¢å¤±è´¥: {err}")
        else:
            match = re.search(r'roomId\\":\\"(\d+)\\"', response.text)
            if match is None or len(match.groups()) < 1:
                logger.warning("æœªæ‰¾åˆ°roomIdï¼Œå¯èƒ½æ˜¯æœªå¼€æ’­çŠ¶æ€ï¼Œä½¿ç”¨live_idä½œä¸ºfallback")
                self.__room_id = self.live_id
                self.is_live = False
            else:
                self.__room_id = match.group(1)
                
            return self.__room_id
    
    def start(self):
        """å¯åŠ¨çˆ¬è™«"""
        logger.info(f"å¼€å§‹æŠ“å–ç›´æ’­é—´: {self.live_id}")
        
        # å¯åŠ¨è‡ªåŠ¨ä¿å­˜çº¿ç¨‹
        self.auto_save_running = True
        self.auto_save_thread = threading.Thread(target=self._auto_save_worker)
        self.auto_save_thread.daemon = True
        self.auto_save_thread.start()
        
        # å¯åŠ¨WebSocketè¿æ¥çº¿ç¨‹
        self.ws_thread = threading.Thread(target=self._connectWebSocket)
        self.ws_thread.daemon = True
        self.ws_thread.start()
    
    def stop(self):
        """åœæ­¢çˆ¬è™«"""
        try:
            logger.info("æ­£åœ¨åœæ­¢æŠ“å–...")
            
            self.is_running = False
            self.auto_save_running = False
            
            if self.ws:
                try:
                    self.ws.close()
                except Exception as e:
                    logger.warning(f"å…³é—­WebSocketæ—¶å‡ºé”™: {e}")
                    
            # ä¿å­˜æœ€ç»ˆæ•°æ®
            self._save_data()
            clear_js_runtime_cache()
            
            logger.info("æŠ“å–å·²åœæ­¢")
            
        except Exception as e:
            logger.error(f"åœæ­¢æŠ“å–æ—¶å‡ºé”™: {e}")

    def _connectWebSocket(self):
        """è¿æ¥WebSocket"""
        retry_count = 0
        max_retries = 3
        retry_delay = 3
        
        while self.is_running and retry_count < max_retries:
            try:
                # ç”ŸæˆWebSocket URL
                wss_url = self._generate_ws_url()
                signature = generateSignature(wss_url)
                if not signature:
                    logger.error("ç”Ÿæˆç­¾åå¤±è´¥")
                    return
                    
                final_url = f"{wss_url}&signature={signature}"
                
                headers = {
                    "cookie": f"ttwid={self.ttwid}",
                    "user-agent": self.user_agent,
                }
                
                logger.info("å¼€å§‹è¿æ¥WebSocket...")
                
                # åˆ›å»ºWebSocketè¿æ¥
                self.ws = websocket.WebSocketApp(
                    final_url,
                    header=[f"User-Agent: {self.user_agent}", f"Cookie: ttwid={self.ttwid}"],
                    on_open=self._on_open,
                    on_message=self._on_message,
                    on_error=self._on_error,
                    on_close=self._on_close
                )
                
                # å¯åŠ¨å¿ƒè·³çº¿ç¨‹
                if hasattr(self, 'heartbeat_thread') and self.heartbeat_thread:
                    try:
                        self.heartbeat_thread.join(timeout=1)
                    except:
                        pass
                self.heartbeat_thread = threading.Thread(target=self._heartbeat)
                self.heartbeat_thread.daemon = True
                self.heartbeat_thread.start()
                
                # è¿è¡ŒWebSocketå®¢æˆ·ç«¯ï¼ˆæ·»åŠ pingå‚æ•°ï¼‰
                self.ws.run_forever(ping_timeout=10, ping_interval=30)
                break
                
            except Exception as e:
                retry_count += 1
                logger.error(f"WebSocketè¿æ¥å¼‚å¸¸ (å°è¯• {retry_count}/{max_retries}): {e}")
                if retry_count < max_retries:
                    time.sleep(retry_delay)
                else:
                    logger.error("WebSocketè¿æ¥å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°")
                    break

    def _generate_ws_url(self):
        """ç”ŸæˆWebSocketè¿æ¥URL"""
        return ("wss://webcast5-ws-web-hl.douyin.com/webcast/im/push/v2/?"
                f"aid=6383&live_id=1&device_platform=web&room_id={self.room_id}"
                "&support_wrds=1&version_code=180800&webcast_sdk_version=1.0.14"
                "&update_version_code=1.0.14&compress=gzip&internal_ext="
                f"internal_src:dim|wss_push_room_id:{self.room_id}|wss_push_did"
                ":7319483754668557238|fetch_time:1721106114633|seq:1|"
                "wss_info:0-1721106114633-0-0&cursor=d-1_u-1_h-1_t-1721106114633"
                "&host=https://live.douyin.com&im_path=/webcast/im/fetch/&user_unique_id="
                f"&identity=audience&need_persist_msg_count=15&heartbeatDuration=0")
    
    
    def _on_open(self, ws):
        """WebSocketè¿æ¥æ‰“å¼€"""
        logger.info("WebSocketè¿æ¥å·²å»ºç«‹")
    
    def _on_message(self, ws, message):
        """å¤„ç†WebSocketæ¶ˆæ¯"""
        try:
            # å…ˆè§£æPushFrameåŒ…è£…
            package = PushFrame().parse(message)
            
            # è§£å‹ç¼©payload
            compressed_data = gzip.decompress(package.payload)
            
            # è§£æprotobufæ¶ˆæ¯
            response = Response().parse(compressed_data)
            
            # å¦‚æœéœ€è¦ACKï¼Œå‘é€ç¡®è®¤æ¶ˆæ¯
            if response.need_ack:
                ack = PushFrame(
                    log_id=package.log_id,
                    payload_type='ack',
                    payload=response.internal_ext.encode('utf-8')
                ).SerializeToString()
                ws.send(ack, websocket.ABNF.OPCODE_BINARY)
            
            # å¤„ç†æ¶ˆæ¯åˆ—è¡¨
            for msg in response.messages_list:
                self._process_message(msg)
                
        except Exception as e:
            logger.error(f"å¤„ç†æ¶ˆæ¯å¤±è´¥: {e}")
            logger.debug(f"æ¶ˆæ¯å†…å®¹: {message[:50]}...")
    
    def _on_error(self, ws, error):
        """WebSocketé”™è¯¯å¤„ç†"""
        logger.error(f"WebSocketé”™è¯¯: {error}")
    
    def _on_close(self, ws, close_status_code, close_msg):
        """WebSocketè¿æ¥å…³é—­"""
        logger.info("WebSocketè¿æ¥å·²å…³é—­")
        
        # å¦‚æœè¿˜åœ¨è¿è¡ŒçŠ¶æ€ï¼Œå°è¯•é‡è¿
        if self.is_running:
            time.sleep(5)
            logger.info("å°è¯•é‡æ–°è¿æ¥...")
            threading.Thread(target=self._connectWebSocket).start()
    
    def _heartbeat(self):
        """å¿ƒè·³ä¿æŒè¿æ¥"""
        while self.is_running and self.ws and self.ws.sock:
            try:
                # å‘é€å¿ƒè·³åŒ… - ä½¿ç”¨protobufæ ¼å¼
                ping_msg = PushFrame(
                    payload_type='hb',
                    payload=b'',
                    log_id=int(time.time() * 1000)
                ).SerializeToString()
                
                self.ws.send(ping_msg, websocket.ABNF.OPCODE_BINARY)
                logger.debug("å‘é€å¿ƒè·³åŒ…...")
                time.sleep(10)  # æ¯10ç§’å‘é€ä¸€æ¬¡å¿ƒè·³åŒ…
            except Exception as e:
                logger.error(f"å¿ƒè·³å‘é€å¤±è´¥: {e}")
                break
    
    def _process_message(self, msg):
        """å¤„ç†å…·ä½“æ¶ˆæ¯ç±»å‹"""
        try:
            method = msg.method
            
            if method == "WebcastChatMessage":
                self._process_chat_message(msg)
            elif method == "WebcastGiftMessage":
                self._process_gift_message(msg)
            elif method == "WebcastMemberMessage":
                self._process_member_message(msg)
            elif method == "WebcastLikeMessage":
                self._process_like_message(msg)
            elif method == "WebcastSocialMessage":
                self._process_follow_message(msg)
            elif method == "WebcastRoomUserSeqMessage":
                self._process_viewer_count(msg)
                
        except Exception as e:
            logger.error(f"å¤„ç†æ¶ˆæ¯ç±»å‹ {msg.method} å¤±è´¥: {e}")
    
    def _process_chat_message(self, msg):
        """å¤„ç†èŠå¤©æ¶ˆæ¯"""
        try:
            chat_msg = ChatMessage().parse(msg.payload)
            user = chat_msg.user
            content = chat_msg.content
            
            message_data = {
                "timestamp": int(time.time()),
                "user_id": str(user.id),
                "nickname": user.nick_name,
                "content": content,
                "type": "chat"
            }
            
            self.data["chat_messages"].append(message_data)
            logger.info(f"ğŸ’¬ {user.nick_name}: {content}")
            
        except Exception as e:
            logger.error(f"å¤„ç†èŠå¤©æ¶ˆæ¯å¤±è´¥: {e}")
    
    def _process_gift_message(self, msg):
        """å¤„ç†ç¤¼ç‰©æ¶ˆæ¯"""
        try:
            gift_msg = GiftMessage().parse(msg.payload)
            user = gift_msg.user
            gift = gift_msg.gift
            
            gift_name = gift.name
            gift_count = gift_msg.repeat_count
            gift_value = gift.diamond_count * gift_count
            
            # ç»Ÿè®¡ç¤¼ç‰©
            if gift_name not in self.data["gifts"]:
                self.data["gifts"][gift_name] = {
                    "count": 0,
                    "total_value": 0,
                    "senders": set()
                }
            
            # ç¡®ä¿senderså§‹ç»ˆæ˜¯setç±»å‹
            if not isinstance(self.data["gifts"][gift_name]["senders"], set):
                self.data["gifts"][gift_name]["senders"] = set(self.data["gifts"][gift_name]["senders"])
            
            self.data["gifts"][gift_name]["count"] += gift_count
            self.data["gifts"][gift_name]["total_value"] += gift_value
            self.data["gifts"][gift_name]["senders"].add(user.nick_name)
            
            logger.info(f"ğŸ {user.nick_name} é€å‡º {gift_name} x{gift_count}")
            
        except Exception as e:
            logger.error(f"å¤„ç†ç¤¼ç‰©æ¶ˆæ¯å¤±è´¥: {e}")
    
    def _process_member_message(self, msg):
        """å¤„ç†è§‚ä¼—è¿›å…¥æ¶ˆæ¯"""
        try:
            member_msg = MemberMessage().parse(msg.payload)
            user = member_msg.user
            
            # å»é‡æ£€æŸ¥
            user_key = str(user.id)
            if user_key not in self.message_cache["members"]:
                # ç¡®ä¿membersæ˜¯setç±»å‹
                if not isinstance(self.data["members"], set):
                    self.data["members"] = set(self.data["members"])
                    
                self.message_cache["members"].add(user_key)
                self.data["members"].add(user.nick_name)
                logger.info(f"ğŸ‘¥ {user.nick_name} è¿›å…¥ç›´æ’­é—´")
            
        except Exception as e:
            logger.error(f"å¤„ç†è§‚ä¼—è¿›å…¥æ¶ˆæ¯å¤±è´¥: {e}")
    
    def _process_like_message(self, msg):
        """å¤„ç†ç‚¹èµæ¶ˆæ¯"""
        try:
            like_msg = LikeMessage().parse(msg.payload)
            count = like_msg.count
            self.data["total_likes"] += count
            
            if count > 1:
                logger.info(f"ğŸ‘ æ”¶åˆ° {count} ä¸ªç‚¹èµ")
                
        except Exception as e:
            logger.error(f"å¤„ç†ç‚¹èµæ¶ˆæ¯å¤±è´¥: {e}")
    
    def _process_follow_message(self, msg):
        """å¤„ç†å…³æ³¨æ¶ˆæ¯"""
        try:
            social_msg = SocialMessage().parse(msg.payload)
            user = social_msg.user
            
            follow_data = {
                "timestamp": int(time.time()),
                "user_id": str(user.id),
                "nickname": user.nick_name
            }
            
            self.data["follows"].append(follow_data)
            logger.info(f"â¤ï¸ {user.nick_name} å…³æ³¨äº†ä¸»æ’­")
            
        except Exception as e:
            logger.error(f"å¤„ç†å…³æ³¨æ¶ˆæ¯å¤±è´¥: {e}")
    
    def _process_viewer_count(self, msg):
        """å¤„ç†è§‚ä¼—äººæ•°æ¶ˆæ¯"""
        try:
            seq_msg = RoomUserSeqMessage().parse(msg.payload)
            total_user = seq_msg.total_user
            self.data["total_viewers"] = total_user
            
        except Exception as e:
            logger.error(f"å¤„ç†è§‚ä¼—äººæ•°æ¶ˆæ¯å¤±è´¥: {e}")
    
    def _auto_save_worker(self):
        """è‡ªåŠ¨ä¿å­˜å·¥ä½œçº¿ç¨‹"""
        while self.auto_save_running:
            time.sleep(self.auto_save_interval)
            if self.auto_save_running:
                self._save_data()
    
    def _save_data(self):
        """ä¿å­˜æ•°æ®åˆ°æ–‡ä»¶"""
        try:
            # è½¬æ¢setä¸ºlistä»¥ä¾¿JSONåºåˆ—åŒ–
            data_copy = self.data.copy()
            data_copy["members"] = list(data_copy["members"])
            
            # å¤„ç†ç¤¼ç‰©æ•°æ®ä¸­çš„set
            for gift_name, gift_data in data_copy["gifts"].items():
                if "senders" in gift_data and isinstance(gift_data["senders"], set):
                    gift_data["senders"] = list(gift_data["senders"])
            
            # æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
            data_copy["stats"] = {
                "total_chat_messages": len(data_copy["chat_messages"]),
                "total_members": len(data_copy["members"]),
                "total_follows": len(data_copy["follows"]),
                "total_gift_types": len(data_copy["gifts"]),
                "save_time": datetime.now().isoformat()
            }
            
            filename = f"{self.live_id}_{self.session_count}_{self.today}.json"
            filepath = os.path.join(self.data_dir, filename)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data_copy, f, ensure_ascii=False, indent=2)
                
            logger.info(f"æ•°æ®å·²ä¿å­˜åˆ°: {filepath}")
            
        except Exception as e:
            logger.error(f"ä¿å­˜æ•°æ®å¤±è´¥: {e}")

def main():
    parser = argparse.ArgumentParser(description='æŠ–éŸ³ç›´æ’­é—´æ•°æ®çˆ¬è™«')
    parser.add_argument('live_id', help='ç›´æ’­é—´ID')
    parser.add_argument('--save-interval', type=int, default=300, 
                       help='è‡ªåŠ¨ä¿å­˜é—´éš”(ç§’)ï¼Œé»˜è®¤300ç§’')
    parser.add_argument('--log-level', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'], 
                       default='INFO', help='æ—¥å¿—çº§åˆ«')
    
    args = parser.parse_args()
    
    # è®¾ç½®æ—¥å¿—çº§åˆ«
    logging.getLogger().setLevel(getattr(logging, args.log_level))
    
    crawler = DouyinLiveCrawler(args.live_id, args.save_interval)
    
    try:
        crawler.start()
        
        # ä¸»å¾ªç¯
        logger.info("çˆ¬è™«å·²å¯åŠ¨ï¼ŒæŒ‰ Ctrl+C åœæ­¢")
        while crawler.is_running:
            time.sleep(1)
            
    except KeyboardInterrupt:
        logger.info("æ”¶åˆ°åœæ­¢ä¿¡å·")
    except Exception as e:
        logger.error(f"è¿è¡Œæ—¶é”™è¯¯: {e}")
    finally:
        crawler.stop()

if __name__ == "__main__":
    main()